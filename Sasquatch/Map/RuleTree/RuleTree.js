import {CoordinateClock} from "../Matrix/Coordinates.js"
import fs from "node:fs"
import path from "node:path"
import {Utils} from "../Utils/Utils.js"

export class RuleTree{
    constructor(map){
		this.map = map
		this.create(map)
    }

	create(map){
		//theta represents the code length which is mathematically related to a minimal set of codes
		//corresponding to the input and output
		//we only want to create the file if its not already created
		if(this.exists(map)){
			this.map = this.import(map)
		}else{
			//1-2 neighbors for 1 dimension; 
			//2-4 for 2 dimensions; 
			//3-6 for 3 dimensions; 
			//4-8 for 4 dimensions 
			this.map['codes']=this.map['codes'].sort()
			this.map['ruleTree']={}
			for(var neighbor_count=this.map['dimension']; neighbor_count<=2*this.map['dimension']; neighbor_count++){
				this.map['ruleTree'][neighbor_count]={}
				this.ruleTree(this.map['ruleTree'][neighbor_count], neighbor_count, this.map['codes'].slice())
			}
			this.export(this.map)
		}		
	}

	exists(map){
		var path = new Utils().resolve('Map/RuleTree/RuleTrees/')
		path+=JSON.stringify(map['dimension'])+"_"+map['omega']+'.RuleTree'
		return fs.existsSync(path)
	}

	export(map){
		var path = new Utils().resolve('Map/RuleTree/RuleTrees/')
		path+=JSON.stringify(map['dimension'])+"_"+map['omega']+'.RuleTree'
		fs.writeFileSync(path, JSON.stringify(map['ruleTree']))
	}

	import(map){
		var path = new Utils().resolve('Map/RuleTree/RuleTrees/')
		path+=JSON.stringify(map['dimension'])+"_"+map['omega']+'.RuleTree'
		var obj = JSON.parse(fs.readFileSync(path))
		map['ruleTree']=obj
		return map
	}

	//if we have a list of symbols, which we know are alphabetically sorted, 
	//and we have a neighbor_count, then we can deterministically create trees
	//and store them for future use. We can pre-load the most commonly used ones
	//into ram and use them at random access speeds (in the future when we have more RAM)

	//if we have 3 neighbors for our tree and 5 symbols, we can optimize, because we are searching
	//the neighborhood in alphabetical order
	//1:{1:{1:r, 2:r, 3:r, 4:r, 5:r} 2:{2:r, 3:r, 4:r, 5:r}, 3:{3:r, 4:r, 5:r}, 4:{4:r, 5:r}, 5{5:r}}
	//2:{2:{2:r, 3:r, 4:r, 5:r}, 3:{3:r, 4:r, 5:r}, 4:{4:r, 5:r}, 5{5:r}}
	//3:3:{3:r, 4:r, 5:r}, 4:{4:r, 5:r}, 5{5:r}}
	//4:{4:{4:r, 5:r}, 5{5:r}}
	//5:{5{5:r}}

	ruleTree(tree, neighbor_count, symbols, payload=[], rules=[]){
		//the number of neighborhoods is symbols.length^(neighborcount+1)
		//where 1 accounts for an empty space
		symbols.sort()
		var symbolcoord1=[]
		var symbolcoord2=[]
		for(var i = 0; i<neighbor_count; i++){
			symbolcoord1.push(0)
			symbolcoord2.push(symbols.length-1)
		}

		var coordinates = new CoordinateClock(symbolcoord1, symbolcoord2).coordinates()
		for(var i = 0; i<coordinates.length; i++){
			for(var j = 0; j<coordinates[i].length; j++){
				this._ruleTree(symbols, coordinates[i].sort(), tree, payload, rules)
			}
		}
	}

	_ruleTree(symbols, coordinates, tree, payload, rules){
		var i = coordinates.shift()
		if(!tree[symbols[i]]&&coordinates.length>=1){
			tree[symbols[i]]={}
			tree = tree[symbols[i]]
			this._ruleTree(symbols, coordinates, tree, payload, rules)
		}else if(tree[symbols[i]]&&coordinates.length>=1){
			tree = tree[symbols[i]]
			this._ruleTree(symbols, coordinates, tree, payload, rules)
		}
		else if(!tree[symbols[i]]&&coordinates.length==0){
			tree[symbols[i]]={}
			if(payload.length){
				tree[symbols[i]]=payload[0]
				rules.push(tree[symbols[i]])
				payload.shift()
			}else{
				tree[symbols[i]]=symbols[Math.floor(Math.random() * symbols.length)]
			}
			return
		}else if(tree[symbols[i]]&& coordinates.length==0){
			tree[symbols[i]]=symbols[Math.floor(Math.random() * symbols.length)] 
			return
		}
	}
	//this recursive strategy follows a tree schema (they are one and the same when used together)
	//therefore the order of the rules are recursively defined (THEREFORE WE SHOULD NOT CHANGE THE SCEHMA OR THE
	//RECURSIVE FUNCTION)
	//if we wish to use the data generated by this strategy
	refresh(tree, symbols, payload, rules=[]){
		for(var i = 0; i<Object.keys(tree).length; i++){
			var keys = Object.keys(tree)
			if(typeof tree[keys[i]]==='string'){
				if(payload){
					//ai rule generation
					tree[keys[i]]=payload[0]
					rules.push(tree[keys[i]])
					payload.shift()
				}else{
					//random rule generation
					tree[keys[i]]=symbols[Math.floor(Math.random() * symbols.length)]
					rules.push(tree[keys[i]])
				}
			}else{
				this.refresh(tree[keys[i]], symbols)
			}
		}
		return rules
	}

	rule(neighborhood){
		//a neighborhood looks like this
		//console.log(neighborhood, neighbor_codes, neighbor_count)
		var neighbor_keys = Object.keys(neighborhood)
		var neighbor_count = neighbor_keys.length
		var neighbor_codes = []
		for(var i = 0; i<neighbor_count; i++){
			neighbor_codes.push(neighborhood[neighbor_keys[i]])
		}
		neighbor_codes.sort()

		var rule = this.map['ruleTree'][neighbor_count]
		for(var i = 0; i<neighbor_count; i++){
			rule = rule[neighbor_codes[i]]
		}
		//returns just a code
		return rule
	}

	hash(map){
		var ruleKeys = Object.keys(map['rules'])
		for(var i = 0; i<ruleKeys.length; i++){
			var rule = JSON.stringify(map['rules'][ruleKeys[i]]['neighborhood'])
			map['rules'][ruleKeys[i]]['nhHash']=createHash('sha256').update(rule).digest('hex'); 
		}

	}
}